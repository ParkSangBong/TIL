이전 코드에서 configure 메서드에 인자로 전달된 MiddlewareConsumer 객체를 이용해서 미들웨어를 어디에 적용할지 관리할 수 있다. apply 메소드의 원형은 다음과 같다.

```typescript
apply(...middleware: (Type<any> | Function)[]): MiddlewareConfigProxy;
```

apply 메소드에 미들웨어 함수 또는 클래스를 콤마로 나열하면 된다.  
이때 미들웨어가 나열된 순서대로 적용이 된다.  
만약 Logger2Middleware 라는 미들웨어가 하나 더 있다고 해 보자.

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class Logger2Middleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('Request2...');
    next();
  }
}
```

그리고 2개 미들웨어를 모두 적용한다면...

```typescript
configure(consumer: MiddlewareConsumer): any {
  consumer
    .apply(LoggerMiddleware, Logger2Middleware)
    .forRoutes('/users')
}
```

/users 경로의 요청에 로그가 2개 찍히는 것을 볼 수 있다.  

forRoutes 메서드의 원형도 살펴보자.  
forRoute는 apply 함수의 리턴타입인 MiddlewareConfigProxy에 정의되어 있다.

```typescript
import { Type } from '../type.interface';
import { RouteInfo } from './middleware-configuration.interface';
import { MiddlewareConsumer } from './middleware-consumer.interface';
export interface MiddlewareConfigProxy {
    exclude(...routes: (string | RouteInfo)[]): MiddlewareConfigProxy;
    forRoutes(...routes: (string | Type<any> | RouteInfo)[]): MiddlewareConsumer;
}
```