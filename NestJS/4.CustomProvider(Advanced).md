# ADVANCED ! - 커스텀 프로바이더 (Custom Provider)

### 이전 문서에서 프로바이더를 모듈에 등록할 때 프로바이더 클래스 이름을 그대로 사용했다.

```typescript
@Module({
  providers: [UsersService],
})
export class AppModule {}
```

### 아직 모듈을 제대로 학습하지는 않았지만 이 방식이 프로바이더를 모듈에 등록하는 일반적인 방법이고 사용하기도 간편했었다.

### 하지만 기능을 확장하다 보면 라이브러리에 선언된 클래스를 가져오거나, 테스트코드에 모의(mock) 객체를 사용하려고 할 때와 같이 이방식을 사용하지 못하는 경우가 있다.

## 그래서 다음 세 가지 경우는 커스텀 프로바이더를 사용해야 한다.

1. Nest 프레임워크가 만들어주는 인스턴스 또는 캐시된 인스턴스 대신 인스턴스를 직접 생성하고 싶은 경우

2. 여러 클래스가 의존 관계에 있을 때 이미 존재하는 클래스를 재사용하고자 할 때

3. 테스트를 위해 모의(mock) 버전으로 프로바이더를 재정의하려는 경우, 이 경우는 이후 유닛 테스트 장에서 배우게 된다.

### 위 코드에서 `@Module` 데코레이터의 인자를 주목해보자. 이 인자의 타입은 `ModuleMetadata`이다.

```typescript
export interface ModuleMetadata {
    /**
     * Optional list of imported modules that export the providers which are
     * required in this module.
     */
    imports?: Array<Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference>;
    /**
     * Optional list of controllers defined in this module which have to be
     * instantiated.
     */
    controllers?: Type<any>[];
    /**
     * Optional list of providers that will be instantiated by the Nest injector
     * and that may be shared at least across this module.
     */
    providers?: Provider[];
    /**
     * Optional list of the subset of providers that are provided by this module
     * and should be available in other modules which import this module.
     */
    exports?: Array<DynamicModule | Promise<DynamicModule> | string | symbol | Provider | ForwardReference | Abstract<any> | Function>;
}
```

프로바이더는 `Provider` 배열로 선언되었다. Nest가 제공하는 Provider의 소스코드를 다시 따라가 보면 다음과 같다.

```typescript
export declare type Provider<T = any> = Type<any> | ClassProvider<T> | ValueProvider<T> | FactoryProvider<T> | ExistingProvider<T>;

export interface ClassProvider<T = any> {
    /**
     * Injection token
     */
    provide: string | symbol | Type<any> | Abstract<any> | Function;
    /**
     * Type (class name) of provider (instance to be injected).
     */
    useClass: Type<T>;
    /**
     * Optional enum defining lifetime of the provider that is injected.
     */
    scope?: Scope;
}

export interface ValueProvider<T = any> {
    /**
     * Injection token
     */
    provide: string | symbol | Type<any> | Abstract<any> | Function;
    /**
     * Instance of a provider to be injected.
     */
    useValue: T;
}

export interface FactoryProvider<T = any> {
    /**
     * Injection token
     */
    provide: string | symbol | Type<any> | Abstract<any> | Function;
    /**
     * Factory function that returns an instance of the provider to be injected.
     */
    useFactory: (...args: any[]) => T;
    /**
     * Optional list of providers to be injected into the context of the Factory function.
     */
    inject?: Array<Type<any> | string | symbol | Abstract<any> | Function>;
    /**
     * Optional enum defining lifetime of the provider that is returned by the Factory function.
     */
    scope?: Scope;
}

export interface ExistingProvider<T = any> {
    /**
     * Injection token
     */
    provide: string | symbol | Type<any> | Abstract<any> | Function;
    /**
     * Provider to be aliased by the Injection token.
     */
    useExisting: any;
}
```

### L1: Provider의 타입을 선언한다. Type를 받을 수 있도록 되어 있기 때문에 클래스 이름을 그대로 쓸 수 있다. 

### 그 외 ClassProvider, ValueProvider, FactoryProvider, ExistingProvider를 제네릭으로 받을 수 있다.

