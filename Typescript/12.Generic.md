# Generics, Any와 다른 점

generic1.ts
```typescript
function helloString(message: string): string {
  return message;
}

function helloNumber(message: number): number {
  return message;
}

// 더 많은 반복된 함수들... generic을 사용해보자

function hello(message: any): any {
  return message;
}

console.log(hello("Park").length);
console.log(hello(39).length);

function helloGeneric<T> (message: T): T {
  return message;
}

console.log(helloGeneric("Park").length);
console.log(helloGeneric(39));
console.log(helloGeneric(true));
```

- hello 의 리턴이 any 이기 때문에 타입 헬퍼가 제대로 되지 않음

- helloGeneric 을 사용하면 정상적으로 사용가능

# Generics Basic

generic2.ts
```typescript
function helloBasic <T, U> (message: T, comment: U): T {
  return message;
}

helloBasic <string, number> ("Park", 39);
helloBasic(36, 39);
```

# Generics Array & Tuple

generic3.ts
```typescript
function helloArray <T> (message: T[]): T{
  return message[0];
}

helloArray(['Hello', 'World']); // function helloArray<string>(message: string[]): string
helloArray(['Hello', 5]); // function helloArray<string | number>(message: (string | number)[]): string | number

function helloTuple <T, K> (message: [T, K]): T{
  return message[0];
}

helloTuple(['hello', 'world']); // function helloTuple<string, string>(message: [string, string]): string
helloTuple(['hello', 5]); // function helloTuple<string, number>(message: [string, number]): string
```

# Generics Function

generic4.ts
```typescript
type HelloFunctionGeneric1 = <T> (message: T) => T;

const helloFunction1: HelloFunctionGeneric1 = <T> (message: T): T => {
  return message;
}

interface HelloFunctionGeneric2 {
  <T> (message: T): T;
}

const helloFunction2: HelloFunctionGeneric2 = <T> (message: T): T => {
  return message;
}
```

# Generics Class

generic5.ts
```typescript
class genericPerson <T, K> {
  private _name: T;
  private _age: K;

  constructor (name: T, age: K) {
    this._name = name;
    this._age = age;
  }
}

new genericPerson("Park");  // constructor genericPerson<string>(name: string): genericPerson<string>
// new genericPerson <string> (39);  // Argument of type 'number' is not assignable to parameter of type 'string'.ts(2345)

new genericPerson("Park", 29);  // constructor genericPerson<string, number>(name: string, age: number): genericPerson<string, number>
// new genericPerson <string, number> ("Park", "age"); // Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)
```

# Generics with extends

generic6.ts
```typescript
class PersonExtends <T extends string | number> {
  private _name: T;

  constructor (name: T) {
    this._name = name;
  }
}

new PersonExtends("Park");
new PersonExtends(39);
new PersonExtends(true);  // Argument of type 'boolean' is not assignable to parameter of type 'string | number'.ts(2345)
// 타입은 항상 가장작은범위로 제한해주는게 컴파일 타임에서 체크할 때 좋다.
```

# keyof & type lookup system

